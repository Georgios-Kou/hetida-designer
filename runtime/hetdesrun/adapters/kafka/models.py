from typing import Any, Literal

from pydantic import BaseModel, Field

from hetdesrun.adapters.generic_rest.external_types import ExternalType
from hetdesrun.datatypes import DataType


class StructureThingNode(BaseModel):
    id: str  # noqa: A003
    parentId: str | None = None
    name: str
    description: str


class KafkaAdapterStructureSink(BaseModel):
    id: str  # noqa: A003
    thingNodeId: str
    name: str
    type: ExternalType
    visible: Literal[True] = True
    path: str = Field(..., description="Display path used in Designer Frontend")
    metadataKey: str | None = None
    filters: dict[str, dict] | None = {}


class KafkaAdapterStructureSource(BaseModel):
    id: str  # noqa: A003
    thingNodeId: str
    name: str
    type: ExternalType
    visible: Literal[True] = True
    path: str = Field(..., description="Display path used in Designer Frontend")
    metadataKey: str | None = None
    filters: dict[str, dict] | None = {}


class InfoResponse(BaseModel):
    id: str  # noqa: A003
    name: str
    version: str


class MultipleSourcesResponse(BaseModel):
    resultCount: int
    sources: list[KafkaAdapterStructureSource]


class MultipleSinksResponse(BaseModel):
    resultCount: int
    sinks: list[KafkaAdapterStructureSink]


class StructureResponse(BaseModel):
    id: str  # noqa: A003
    name: str
    thingNodes: list[StructureThingNode]
    sources: list
    sinks: list[KafkaAdapterStructureSink]


class KafkaConfig(BaseModel):
    display_name: str = Field(
        ...,
        description="Name to show to user in offered sources/sinks.",
        min_length=1,
    )
    topic: str = Field(..., description="Kafka topic", min_length=1)
    kafka_cluster_config: Any = Field({"bootstrap_servers": []})
    types: list[ExternalType] | None = Field(
        None, description="All types that should be offered/accepted by this config"
    )
    producable: bool = True
    consumable: bool = False
    producer_config: dict = {}
    consumer_config: dict = {}
    offer_sources_and_sinks: bool = True
    allowed_types: list | None = Field(
        None,
        description="Allowed types. null/unset means every type is allowed."
        " Determines which sources and sinks are offered.",
    )


def kafka_configs_consumable_together(kafka_configs: list[KafkaConfig]) -> bool:
    """Check whether a collection of kafka_configs can be consumed together

    This should be checked for the kafka configs corresponding to all input wirings
    to the kafka adapter when in consuming mode.
    """
    return (
        len(
            {
                (kc.topic, kc.consumer_config, kc.kafka_cluster_config)
                for kc in kafka_configs
            }
        )
        == 1
    )


class KafkaWrappedHdData(BaseModel):
    content__: Any = Field(
        ...,
        alias="__content__",
        description="A json object representing the data of type data_type."
        " The format is that of direct provisioning",
    )
    data_type: DataType = Field(
        ..., description="The hetida designer datatype of __content__"
    )
    output_name: str | None = Field(
        None,
        description="If data was generated by a hetida designer trafo, this is"
        " the name of the transformation output from which the was produced.",
    )
    transformation_id: str | None = Field(
        None,
        description="If data was generated by a hetida designer trafo, this is"
        " the id of the transformation that generated the data",
    )
    job_id: str | None = Field(
        None,
        description="If data was generated by a hetida designer trafo, this is"
        " the job id of the execution. You may also provide this when generating"
        " Kafka messages from other sources that should be handled by hetida designer"
        " in order to trace job progress.",
    )
